'''
풀이

대강 문제를 요약하자면 해시의 개요와 해시 함수를 만드는 방법에 대한 것이다.
해시란 임의의 숫자를 고정된 범위 내의 출력으로 변환하는 것이라는 것이다.
그렇기에 대표적인 사용처가 자료의 저장과 탐색가 된다.

여기에 해석을 덧붙이자면, 사람들의 이름을 저장한다고 해보자.
만약 이를 리스트나 배열의 방식 그대로만을 사용하여 저장한다면, 탐색에 대한 시간 복잡도가 O(n)이 나올 것이다.
하지만 만약 사람들의 성씨로 미리 분류하여 저장을 한다면, 탐색 시에 성씨로 먼저 탐색을 하면 되므로 그 시간이 훨씬 줄어들게 된다.
그렇기에 대표적인 사용처가 자료의 저장과 탐색이 될 수 있다.

물론 예시에 들었던 성씨를 그대로 사용하게 되면, 효율적이지 못할 것이다.(예로 들어, 저장된 사람의 각각의 성씨가 모두 다르면 그대로 O(n)이 나올 것이다.)
따라서 우리는 이를 임의의 숫자와 같은 형태로 치환하게 되는 데 이것을 해시 값이라 부르고, 이러한 해시의 형태로 변환시켜주는 수식이 해시 함수이다.

이번 문제는 이러한 함수를 만드는 방법이다.
함수는 문제처럼 간단히 자리의 숫자를 변환하여 모두 합하는 방법이 있을 수 있다.
하지만 가장 큰 문제는 "해시 충돌"이다.
문제에서 설명한대로 비둘기집 원리에 따르면, 사실상 해시 충돌은 막을 수 없다.
예로 들어, 표현이 가능한 범위가 촤대 N개까지인 해시 값을 출력한다고 할 때, (N + 1)개의 숫자가 있다면 하나 이상은 무조건 동일한 해시 값을 가지게 된다.
때문에, 우리가 고려할 점은 해시 충돌을 최대한 피하는 점인데, 문제에서 말하는 좋은 해시 중 하나는 작은 변화가 해시 값에 큰 변화을 주는 것이다.
그래서 이번 문제에는 거듭제곱을 이용한 문제를 푼 것이다.

이제 문제 풀이로 돌아와서, 결국 각 자리의 알파벳에 할당된 값에 31에 각 자리수만큼 제곱한 값을 곱하고, 놀랍게도 소수인 1234567891을 나눈 나머지를 출력하면 되는 것이다.
물론 이것을 일일이 계산하기에는 길이가 50까지 가게 되면 무리가 있다.
그렇기에 31을 곱할 때마다 1234567891씩 나누고 마지막으로 자리의 알파벳에 한 번 더 곱한 뒤에 1234567891로 나눈 나머지를 구하면,
1234567891을 넘지 않는 선에 계산이 이루어지므로 시간이나 메모리에 가해지는 부담을 줄일 수 있다.
'''

# fast IO
from sys import stdin
input = stdin.readline

# 알파벳에 고유 번호 부여
atoi = {}
for i, a in enumerate("abcdefghijklmnopqrstuvwxyz"):
    atoi[a] = i + 1

# 문자열의 길이와 문자열 입력
strLen = int(input())
alphaStr = input()

# 각 자리 수에 해시 함수 적용
result = 0
for i in range(strLen):
    exponent = 1
    for _ in range(i):
        exponent *= 31
        exponent %= 1234567891
    
    result += atoi[alphaStr[i]] * exponent
    result %= 1234567891

# 결과 값 출력
print(result)